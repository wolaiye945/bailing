<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>百聆(BaiLing) - 智能语音对话</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        :root {
            --primary: #5271ff;
            --primary-soft: rgba(82, 113, 255, 0.1);
            --accent: #ff8c42; /* 温暖的橘色 */
            --bg-page: #f8faff;
            --bg-card: rgba(255, 255, 255, 0.8);
            --text-main: #2d3436;
            --text-muted: #636e72;
            --glass-border: rgba(255, 255, 255, 0.5);
            --shadow-soft: 0 10px 30px rgba(0, 0, 0, 0.05);
            --transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }

        body {
            background-color: var(--bg-page);
            color: var(--text-main);
            min-height: 100vh;
            overflow-x: hidden;
            line-height: 1.6;
        }

        /* 背景装饰 */
        .ambient-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: 
                radial-gradient(circle at 10% 20%, rgba(82, 113, 255, 0.03) 0%, transparent 40%),
                radial-gradient(circle at 90% 80%, rgba(255, 140, 66, 0.03) 0%, transparent 40%);
            filter: blur(80px);
        }

        /* 顶部导航 */
        header {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px 40px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
            background: rgba(248, 250, 255, 0.7);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(0, 0, 0, 0.03);
        }

        header .logo {
            font-size: 1.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--primary), var(--accent));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* 虚拟形象容器 */
        .avatar-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            height: 300px;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
        }

        /* 当有对话时，特效不再位移，保持居中以增强沉浸感 */
        body.has-dialogue .avatar-container {
            top: 50%;
            transform: translate(-50%, -50%) scale(1);
        }

        #avatar-canvas {
            width: 100%;
            height: 100%;
        }

        .avatar-status-text {
            display: none; /* 隐藏状态文字 */
        }

        /* 对话记录抽屉 - 侧边滑出式 */
        #dialogue-container {
            position: fixed;
            right: -100%; /* 默认隐藏 */
            top: 0;
            width: 100%;
            max-width: 450px;
            height: 100vh;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(25px);
            z-index: 1000;
            padding: 0; /* 移除内边距，交给内部元素处理 */
            overflow-y: auto;
            transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1);
            box-shadow: -10px 0 30px rgba(0, 0, 0, 0.05);
            border-left: 1px solid var(--glass-border);
            display: flex;
            flex-direction: column;
        }

        /* 悬停头部 */
        .dialogue-header-sticky {
            position: sticky;
            top: 0;
            left: 0;
            width: 100%;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px 25px;
            z-index: 1001;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #messages-list {
            padding: 25px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            padding-bottom: 120px; /* 留出底部控制条空间 */
        }

        #dialogue-container.active {
            right: 0;
        }

        /* 移动端适配 */
        @media (max-width: 600px) {
            #dialogue-container {
                max-width: 100%;
            }
        }

        /* 消息样式 */
        .message {
            max-width: 85%;
            padding: 16px 24px;
            border-radius: 24px;
            position: relative;
            animation: slideUp 0.5s cubic-bezier(0.23, 1, 0.32, 1) forwards;
            font-size: 1.05rem;
            box-shadow: var(--shadow-soft);
            border: 1px solid var(--glass-border);
        }

        @keyframes slideUp {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .message.role-user {
            align-self: flex-end;
            background: var(--primary);
            color: white;
            border-bottom-right-radius: 4px;
        }

        .message.role-assistant, .message.role-bot {
            align-self: flex-start;
            background: var(--bg-card);
            color: var(--text-main);
            border-bottom-left-radius: 4px;
        }

        .message.role-system {
            align-self: center;
            background: transparent;
            box-shadow: none;
            border: none;
            font-size: 0.85rem;
            color: var(--text-muted);
            text-align: center;
        }

        .message-content {
            line-height: 1.7;
        }

        /* Markdown 内容微调 */
        .message-content p { margin-bottom: 0.8rem; }
        .message-content p:last-child { margin-bottom: 0; }
        .message-content pre {
            background: #f1f3f9;
            padding: 15px;
            border-radius: 12px;
            margin: 10px 0;
            overflow-x: auto;
        }

        /* 底部控制台 */
        .controls-bar {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 12px 30px;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(20px);
            border-radius: 50px;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.08);
            border: 1px solid var(--glass-border);
            z-index: 100;
            transition: var(--transition);
        }

        .control-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            cursor: pointer;
            transition: var(--transition);
            background: transparent;
            color: var(--text-main);
        }

        .control-btn:hover {
            background: var(--primary-soft);
            color: var(--primary);
            transform: translateY(-2px);
        }

        .control-btn.main-action {
            width: 65px;
            height: 65px;
            background: var(--primary);
            color: white;
            box-shadow: 0 8px 20px rgba(82, 113, 255, 0.3);
        }

        .control-btn.main-action:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 12px 25px rgba(82, 113, 255, 0.4);
        }

        .control-btn.stop { color: #ff5e57; }
        .control-btn.stop:hover { background: rgba(255, 94, 87, 0.1); }

        .control-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            transform: none !important;
        }

        /* 日志和设置切换 */
        .side-actions {
            position: fixed;
            right: 30px;
            bottom: 40px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 100;
        }

        .side-btn {
            width: 45px;
            height: 45px;
            border-radius: 12px;
            background: var(--bg-card);
            border: 1px solid var(--glass-border);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: var(--shadow-soft);
            transition: var(--transition);
            color: var(--text-muted);
        }

        .side-btn:hover {
            transform: translateX(-5px);
            color: var(--primary);
        }

        /* 抽屉样式 (用于日志和设置) */
        .drawer {
            position: fixed;
            right: -400px;
            top: 0;
            width: 350px;
            height: 100%;
            background: var(--bg-card);
            backdrop-filter: blur(20px);
            box-shadow: -10px 0 30px rgba(0, 0, 0, 0.05);
            z-index: 200;
            transition: var(--transition);
            padding: 30px;
            display: flex;
            flex-direction: column;
        }

        .drawer.active { right: 0; }

        .drawer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        }

        .log-content {
            flex: 1;
            overflow-y: auto;
            font-size: 0.85rem;
            color: var(--text-muted);
        }

        .log-entry {
            padding: 8px 0;
            border-bottom: 1px solid rgba(0, 0, 0, 0.02);
            word-break: break-all;
        }

        .log-entry.info { color: var(--primary); }
        .log-entry.warning { color: #f1c40f; }
        .log-entry.error { color: var(--accent); }
        .log-entry.debug { color: #95a5a6; opacity: 0.8; font-family: monospace; font-size: 0.75rem; }
        .log-entry.system { color: var(--text-muted); font-style: italic; }

        /* 模态框通用样式 */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            z-index: 1000;
            backdrop-filter: blur(10px);
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-container {
            max-width: 800px;
            margin: 50px auto;
            background: var(--bg-card);
            border-radius: 24px;
            border: 1px solid var(--glass-border);
            padding: 30px;
            height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: var(--shadow-soft);
            position: relative;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-header h2 {
            margin: 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .modal-content {
            flex: 1;
            overflow-y: auto;
            padding-right: 10px;
        }

        .modal-footer {
            margin-top: 20px;
            display: flex;
            justify-content: flex-end;
            gap: 15px;
        }

        .close-btn {
            background: none;
            border: none;
            color: var(--text-main);
            font-size: 1.5rem;
            cursor: pointer;
            transition: var(--transition);
        }

        .close-btn:hover {
            color: var(--accent);
            transform: rotate(90deg);
        }

        /* 响应式适配 */
        @media (max-width: 768px) {
            header { padding: 15px 20px; }
            header .logo span { font-size: 1.2rem; }
            
            .avatar-container { width: 320px; height: 320px; }
            body.has-dialogue .avatar-container { 
                top: 60px; 
                transform: translate(-50%, 0) scale(0.6); 
                opacity: 0.8;
            }
            
            #dialogue-container { 
                background: rgba(255, 255, 255, 0.95);
            }
            
            .message { max-width: 95%; padding: 12px 16px; font-size: 0.95rem; }
            
            .controls-bar { 
                width: 90%; 
                bottom: 20px; 
                padding: 10px 20px;
                gap: 15px;
                justify-content: center;
            }
            .control-btn { width: 48px; height: 48px; font-size: 1.2rem; }
            .control-btn.main-action { width: 60px; height: 60px; }
            
            .side-actions { 
                right: 10px; 
                bottom: 110px; 
                gap: 8px;
            }
            .side-btn { width: 38px; height: 38px; }
            
            .drawer { width: 100%; right: -100%; padding: 20px; }
            .modal-container { width: 98%; margin: 5px auto; height: 98vh; padding: 10px; border-radius: 12px; }
        }
    </style>
</head>
<body>
    <div class="ambient-bg"></div>

    <header>
        <div class="logo">
            <i class="fas fa-feather-alt"></i>
            <span>百聆 BaiLing</span>
        </div>
        <div class="header-actions">
            <a href="/logout" class="side-btn" title="退出登录">
                <i class="fas fa-sign-out-alt"></i>
            </a>
        </div>
    </header>

    <div class="avatar-container">
        <canvas id="avatar-canvas"></canvas>
        <div class="avatar-status-text" id="avatar-status">等待连接...</div>
    </div>

    <main id="dialogue-container">
        <div class="dialogue-header-sticky">
            <h3 style="margin: 0; color: var(--primary);">对话记录</h3>
            <button class="close-btn" style="font-size: 1.2rem;" onclick="document.getElementById('dialogue-container').classList.remove('active')">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div id="messages-list">
            <!-- 消息将通过 JS 动态插入 -->
        </div>
    </main>

    <div class="controls-bar">
        <button id="dialogueToggle" class="control-btn" title="显示对话记录" style="position: relative;">
            <i class="fas fa-comment-alt"></i>
            <span id="messageBadge" style="display: none; position: absolute; top: 5px; right: 5px; width: 10px; height: 10px; background: #ff5e57; border-radius: 50%; border: 2px solid white;"></span>
        </button>
        <button id="startBtn" class="control-btn main-action" title="开始对话">
            <i class="fas fa-microphone"></i>
        </button>
        <button id="stopBtn" class="control-btn stop" title="停止" disabled>
            <i class="fas fa-stop"></i>
        </button>
        <button id="interruptBtn" class="control-btn" title="打断" disabled>
            <i class="fas fa-hand-paper"></i>
        </button>
    </div>

    <div class="side-actions">
        <button id="logToggle" class="side-btn" title="查看日志">
            <i class="fas fa-terminal"></i>
        </button>
        <button id="tempFilesBtn" class="side-btn" title="临时文件">
            <i class="fas fa-folder-open"></i>
        </button>
        <button id="adminBtn" class="side-btn" title="管理面板" style="display: none;">
            <i class="fas fa-user-shield"></i>
        </button>
    </div>

    <!-- 日志抽屉 -->
    <div class="drawer" id="logDrawer">
        <div class="drawer-header">
            <h3>系统日志</h3>
            <button class="side-btn close-drawer"><i class="fas fa-times"></i></button>
        </div>
        <div class="log-content" id="logContent">
            <div class="log-entry">系统已就绪</div>
        </div>
    </div>

    <!-- 临时文件模态框 -->
    <div id="tempFilesModal" class="modal">
        <div class="modal-container">
            <div class="modal-header">
                <h2><i class="fas fa-folder-open"></i> 临时文件管理</h2>
                <button id="closeTempFilesBtn" class="close-btn">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div id="tempFilesContent" class="modal-content">
                <div style="text-align: center; padding: 50px;">
                    <i class="fas fa-spinner fa-spin" style="font-size: 2rem; color: var(--primary);"></i>
                    <p>加载中...</p>
                </div>
            </div>
            <div class="modal-footer">
                <button id="refreshTempFilesBtn" class="control-btn" style="padding: 10px 20px; border-radius: 12px; font-size: 0.9rem;">
                    <i class="fas fa-sync"></i> 刷新
                </button>
                <button id="batchDeleteBtn" class="control-btn stop" style="padding: 10px 20px; border-radius: 12px; font-size: 0.9rem;" disabled>
                    <i class="fas fa-trash"></i> 批量删除 (<span id="selectedCount">0</span>)
                </button>
            </div>
        </div>
    </div>

    <!-- 管理员面板 -->
    <div id="adminPanelModal" class="modal">
        <div class="modal-container" style="max-width: 900px;">
            <div class="modal-header">
                <h2 style="color: var(--primary);"><i class="fas fa-user-shield"></i> 系统管理面板</h2>
                <button id="closeAdminPanelBtn" class="close-btn">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div id="adminPanelContent" class="modal-content">
                <div style="text-align: center; padding: 50px;">
                    <i class="fas fa-spinner fa-spin" style="font-size: 2rem; color: var(--primary);"></i>
                    <p>加载活跃连接...</p>
                </div>
            </div>
            <div class="modal-footer">
                <button id="refreshAdminBtn" class="control-btn" style="padding: 10px 20px; border-radius: 12px; font-size: 0.9rem; background: var(--primary); color: white;">
                    <i class="fas fa-sync"></i> 刷新列表
                </button>
            </div>
        </div>
    </div>

    <script>
        // 全局错误捕获，方便调试
        window.onerror = function(message, source, lineno, colno, error) {
            const errorMsg = `[JS错误] ${message} at ${source}:${lineno}:${colno}`;
            console.error(errorMsg, error);
            if (typeof addLog === 'function') {
                addLog(errorMsg, 'error');
            }
            return false;
        };

        function genId() {
          try {
            if (typeof crypto !== 'undefined' && crypto.getRandomValues) {
              const arr = crypto.getRandomValues(new Uint32Array(1));
              return arr[0].toString(16);
            }
          } catch (e) {
            console.warn("crypto.getRandomValues failed, using Math.random fallback", e);
          }
          return Math.random().toString(16).slice(2, 10);
        }
        function getUserId() {
          let uid = sessionStorage.getItem("user_id");
          if (!uid) {
            uid = genId();
            sessionStorage.setItem("user_id", uid);
          }
          return uid;
        }

        function getConnId() {
          let cid = sessionStorage.getItem("conn_id");
          if (!cid) {
            cid = genId();
            sessionStorage.setItem("conn_id", cid);
          }
          return cid;
        }

        const userId = getUserId();
        const connId = getConnId();
        let currentUser = null;
        
        // 全局音频状态，提前声明以供特效逻辑使用
        let globalAudioContext = null;
        let globalAnalyser = null;
        let frequencyData = null;
        
        console.log("Your user_id is", userId, "conn_id is", connId);

        // DOM元素
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const interruptBtn = document.getElementById('interruptBtn');
        const logToggle = document.getElementById('logToggle');
        const avatarStatusText = document.getElementById('avatar-status');
        const dialogueContainer = document.getElementById('dialogue-container');
        const logDrawer = document.getElementById('logDrawer');
        const logContent = document.getElementById('logContent');
        const tempFilesBtn = document.getElementById('tempFilesBtn');
        const tempFilesModal = document.getElementById('tempFilesModal');
        const closeTempFilesBtn = document.getElementById('closeTempFilesBtn');
        const tempFilesContent = document.getElementById('tempFilesContent');
        const refreshTempFilesBtn = document.getElementById('refreshTempFilesBtn');
        const batchDeleteBtn = document.getElementById('batchDeleteBtn');
        const selectedCountSpan = document.getElementById('selectedCount');
        const adminBtn = document.getElementById('adminBtn');
        const adminPanelModal = document.getElementById('adminPanelModal');
        const closeAdminPanelBtn = document.getElementById('closeAdminPanelBtn');
        const adminPanelContent = document.getElementById('adminPanelContent');
        const dialogueToggle = document.getElementById('dialogueToggle');
        const messageBadge = document.getElementById('messageBadge');

        dialogueToggle.addEventListener('click', () => {
            dialogueContainer.classList.toggle('active');
            if (dialogueContainer.classList.contains('active')) {
                messageBadge.style.display = 'none';
            }
        });
        const refreshAdminBtn = document.getElementById('refreshAdminBtn');

        // 粒子虚拟形象逻辑
        class ParticleAvatar {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                if (!this.canvas) {
                    console.error(`Canvas element with id '${canvasId}' not found`);
                    return;
                }
                this.ctx = this.canvas.getContext('2d');
                if (!this.ctx) {
                    console.error("Could not get 2D context for canvas");
                    return;
                }
                this.state = 'idle'; 
                this.width = 300;
                this.height = 300;
                this.baseRadius = 70;
                this.targetBaseRadius = 70;
                this.hue = 220; 
                this.targetHue = 220;
                this.pointCount = 100; // 增加点数使线条更圆滑
                this.smoothedData = new Array(this.pointCount).fill(0);
                this.animationId = null;
                
                // 多层配置：[不透明度, 粗细, 旋转速度系数]
                this.layers = [
                    { opacity: 0.6, width: 3, speed: 1.0, phase: 0 },
                    { opacity: 0.3, width: 1.5, speed: -0.7, phase: Math.PI / 3 },
                    { opacity: 0.2, width: 1, speed: 1.4, phase: Math.PI * 2 / 3 }
                ];

                this.init();
                this.animate();
                window.addEventListener('resize', () => this.init());
            }

            init() {
                if (!this.canvas || !this.ctx) return;
                const rect = this.canvas.getBoundingClientRect();
                this.width = rect.width || 300;
                this.height = rect.height || 300;
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width = this.width * dpr;
                this.canvas.height = this.height * dpr;
                this.ctx.scale(dpr, dpr);

                // 根据画布大小动态调整基础半径
                // 默认 300px 下基础半径为 70
                const scale = this.width / 300;
                this.baseRadius = 70 * scale;
                this.targetBaseRadius = this.baseRadius;
            }

            setState(state) {
                this.state = state;
                const scale = this.width / 300;
                if (state === 'listening') {
                    this.targetHue = 210; // 亮蓝色
                    this.targetBaseRadius = 80 * scale;
                } else if (state === 'thinking') {
                    this.targetHue = 280; // 紫色
                    this.targetBaseRadius = 75 * scale;
                } else if (state === 'speaking') {
                    this.targetHue = 30;  // 温暖的橙色
                    this.targetBaseRadius = 85 * scale;
                } else {
                    this.targetHue = 220; // 柔和蓝
                    this.targetBaseRadius = 70 * scale;
                }
            }

            draw() {
                if (!this.ctx || !this.width) return;
                const centerX = this.width / 2;
                const centerY = this.height / 2;
                
                // 物理平滑过渡：基础半径和色相
                this.baseRadius += (this.targetBaseRadius - this.baseRadius) * 0.1;
                // 色相环绕处理
                let hueDiff = this.targetHue - this.hue;
                if (Math.abs(hueDiff) > 180) hueDiff -= Math.sign(hueDiff) * 360;
                this.hue = (this.hue + hueDiff * 0.05 + 360) % 360;

                this.ctx.clearRect(0, 0, this.width, this.height);
                
                let hasAudio = false;
                if (globalAnalyser && frequencyData) {
                    globalAnalyser.getByteFrequencyData(frequencyData);
                    for(let i=0; i<15; i++) { if(frequencyData[i] > 10) { hasAudio = true; break; } }
                }
                
                const time = Date.now() * 0.0015;
                const isVeryIdle = this.state === 'idle' && !hasAudio;
                const scale = this.width / 300;
                
                // 1. 绘制中心柔光背景 (Glow Foundation)
                const bgGradient = this.ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, this.baseRadius * 2);
                const bgOpacity = isVeryIdle ? 0.05 : 0.15;
                bgGradient.addColorStop(0, `hsla(${this.hue}, 80%, 60%, ${bgOpacity})`);
                bgGradient.addColorStop(1, `hsla(${this.hue}, 80%, 60%, 0)`);
                this.ctx.fillStyle = bgGradient;
                this.ctx.fillRect(0, 0, this.width, this.height);

                this.ctx.save();
                this.ctx.globalCompositeOperation = 'lighter';
                
                // 2. 绘制多层波纹
                this.layers.forEach((layer, lIdx) => {
                    this.ctx.beginPath();
                    this.ctx.lineWidth = (isVeryIdle ? layer.width * 0.7 : layer.width) * scale;
                    const alpha = isVeryIdle ? layer.opacity * 0.4 : layer.opacity;
                    this.ctx.strokeStyle = `hsla(${this.hue}, 90%, 70%, ${alpha})`;
                    
                    // 添加发光效果
                    this.ctx.shadowBlur = (isVeryIdle ? 5 : 15) * scale;
                    this.ctx.shadowColor = `hsla(${this.hue}, 90%, 70%, ${alpha})`;

                    for (let i = 0; i <= this.pointCount; i++) {
                        const angle = (i / this.pointCount) * Math.PI * 2;
                        
                        let audioVal = 0;
                        if (!isVeryIdle) {
                            // 不同层取不同的频率段，增加灵动感
                            let freqStep = Math.floor(frequencyData.length / 3);
                            let freqIdx = (lIdx * freqStep + Math.floor(i % (this.pointCount/2))) % frequencyData.length;
                            audioVal = (frequencyData[freqIdx] / 255) * (1 + lIdx * 0.2);
                        }
                        
                        // 平滑音频数据
                        const idx = i % this.pointCount;
                        this.smoothedData[idx] += (audioVal - this.smoothedData[idx]) * 0.15;
                        const val = this.smoothedData[idx];

                        // 复杂的波形组合
                        let wave = 0;
                        const phaseShift = time * layer.speed + layer.phase;
                        
                        if (this.state === 'thinking') {
                            wave = Math.sin(angle * 6 + phaseShift * 3) * 8 + Math.cos(angle * 3 + phaseShift) * 4;
                        } else if (this.state === 'listening') {
                            wave = Math.sin(angle * 4 + phaseShift * 2) * 6;
                        } else if (this.state === 'speaking') {
                            wave = Math.sin(angle * 2 + phaseShift * 5) * (10 + val * 20);
                        } else {
                            // Idle breathing organic wave
                            wave = Math.sin(angle * 3 + phaseShift) * 3 + Math.cos(angle * 2 + phaseShift * 0.5) * 2;
                        }

                        // 缩放 wave 和音频增量
                        const radius = this.baseRadius + (wave * scale) + (val * 60 * scale * (1 - lIdx * 0.2));
                        
                        // 边界保护：确保 radius 不超过画布的一半（带一点边距）
                        const maxAllowedRadius = (Math.min(this.width, this.height) / 2) - 5;
                        const finalRadius = Math.min(radius, maxAllowedRadius);

                        const x = centerX + Math.cos(angle) * finalRadius;
                        const y = centerY + Math.sin(angle) * finalRadius;

                        if (i === 0) {
                            this.ctx.moveTo(x, y);
                        } else {
                            this.ctx.lineTo(x, y);
                        }
                    }
                    
                    this.ctx.closePath();
                    this.ctx.stroke();
                });
                
                this.ctx.restore();

                // 3. 漂浮的灵动微粒
                const pCount = isVeryIdle ? 6 : 15;
                for (let i = 0; i < pCount; i++) {
                    const pSpeed = (0.1 + (i % 3) * 0.05);
                    const pAngle = (time * pSpeed) + (i / pCount) * Math.PI * 2;
                    const pDist = this.baseRadius + (50 * scale) + Math.sin(time * 0.5 + i) * (10 * scale);
                    
                    // 同样对微粒位置做边界保护
                    const maxAllowedDist = (Math.min(this.width, this.height) / 2) - 10;
                    const finalDist = Math.min(pDist, maxAllowedDist);
                    
                    const px = centerX + Math.cos(pAngle) * finalDist;
                    const py = centerY + Math.sin(pAngle) * finalDist;
                    
                    const pSize = (Math.sin(time + i) * 1 + 1.5) * scale;
                    this.ctx.beginPath();
                    this.ctx.arc(px, py, pSize, 0, Math.PI * 2);
                    this.ctx.fillStyle = `hsla(${this.hue}, 80%, 80%, ${isVeryIdle ? 0.15 : 0.4})`;
                    this.ctx.fill();
                    
                    // 微粒也带一点发光
                    if (!isVeryIdle) {
                        this.ctx.shadowBlur = 10 * scale;
                        this.ctx.shadowColor = `hsla(${this.hue}, 80%, 80%, 0.5)`;
                    }
                }
            }

            animate() {
                this.draw();
                this.animationId = requestAnimationFrame(() => this.animate());
            }
        }

        const avatar = new ParticleAvatar('avatar-canvas');

        let selectedFiles = new Set();
        let dialogueHistory = []; // 对话历史记录

        // 获取用户信息并更新 UI
        async function fetchUserInfo() {
            try {
                const response = await fetch('/api/me');
                if (response.ok) {
                    currentUser = await response.json();
                    console.log("Logged in as:", currentUser);
                    if (currentUser.role === 'admin') {
                        adminBtn.style.display = 'flex';
                    }
                }
            } catch (err) {
                console.error("Failed to fetch user info:", err);
            }
        }
        fetchUserInfo();

        // 状态管理
        let websocket = null;
        let player = null;
        let recorder = null;
        let connectionStatus = 'disconnected';
        let logsVisible = false;
        let reconnectAttempts = 0;
        const maxReconnectAttempts = 5;
        const reconnectDelay = 3000;
        let isManuallyStopped = false;

        // 更新状态显示
        function updateStatus(status, message) {
            // status: connecting, connected, disconnected, processing, thinking, responding, listening, speaking
            connectionStatus = status;
            
            const statusMap = {
                'connecting': { text: '正在连接...', state: 'thinking' },
                'connected': { text: '已连接，准备就绪', state: 'idle' },
                'disconnected': { text: '连接已断开', state: 'idle' },
                'processing': { text: '正在处理语音...', state: 'thinking' },
                'thinking': { text: '正在思考中...', state: 'thinking' },
                'responding': { text: '百聆正在回复...', state: 'speaking' },
                'listening': { text: '正在倾听...', state: 'listening' },
                'recording': { text: '正在倾听...', state: 'listening' },
                'speaking': { text: '正在说话...', state: 'speaking' },
                'idle': { text: '就绪', state: 'idle' }
            };

            const info = statusMap[status] || { text: message || status, state: 'idle' };
            avatarStatusText.textContent = info.text;
            avatar.setState(info.state);

            // 更新按钮状态
            if (status === 'listening' || status === 'speaking' || status === 'thinking' || status === 'connected') {
                startBtn.disabled = true;
                stopBtn.disabled = false;
                interruptBtn.disabled = false;
            } else if (status === 'disconnected') {
                startBtn.disabled = false;
                stopBtn.disabled = true;
                interruptBtn.disabled = true;
            }
        }

        // 添加日志
        function addLog(message, type = 'system') {
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.innerHTML = `<span style="opacity: 0.5; font-size: 0.8em; margin-right: 8px;">${new Date().toLocaleTimeString()}</span> ${message}`;
            logContent.appendChild(entry);
            logContent.scrollTop = logContent.scrollHeight;
        }

        // 抽屉逻辑
        logToggle.addEventListener('click', () => {
            logDrawer.classList.add('active');
        });

        // 修复日志关闭按钮事件绑定
        const logCloseBtn = logDrawer.querySelector('.close-drawer');
        if (logCloseBtn) {
            logCloseBtn.addEventListener('click', () => {
                logDrawer.classList.remove('active');
            });
        }

        async function connect() {
            // 在用户点击 connect 时，立即尝试初始化和恢复 AudioContext
            // 这是绕过浏览器自动播放限制的最有效时机
            initAudioContext();
            
            // isManuallyStopped 只在 connect 内部作为判断，确保点击开始时能重置它
            if (isManuallyStopped) {
                addLog("检测到手动停止状态，取消自动连接", 'warning');
                return;
            }
            
            updateStatus("connecting", `连接中 (${reconnectAttempts + 1}/${maxReconnectAttempts})...`);
            addLog(`尝试连接到服务器 (第 ${reconnectAttempts + 1} 次)...`);

            try {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const currentWebsocket = new WebSocket(`${protocol}//${window.location.host}/ws?user_id=${userId}&connection_id=${connId}`);
                websocket = currentWebsocket;

                websocket.binaryType = 'arraybuffer';

                websocket.onopen = async () => {
                    if (websocket !== currentWebsocket) return;
                    reconnectAttempts = 0;
                    updateStatus("connected", "已连接，准备录音...");
                    addLog("WebSocket连接已建立");

                    player = new AudioPlayer(updateStatus, websocket);
                    recorder = new WebRecorder(websocket);

                    const started = await recorder.start();
                    if (started) {
                        updateStatus("recording", "录音中...");
                        startBtn.disabled = true;
                        stopBtn.disabled = false;
                        interruptBtn.disabled = false;
                    }
                };

                websocket.onmessage = async (event) => {
                    if (websocket !== currentWebsocket) return;
                    
                    if (typeof event.data === 'string') {
                        try {
                            const message = JSON.parse(event.data);
                            if (message.type === 'interrupt') {
                                player.interrupt();
                                updateStatus("disconnected", "收到打断指令");
                                addLog("收到服务器打断指令", 'warning');
                            } else if (message.type == 'update_dialogue') {
                                updateDialogue(message.data);
                            } else if (message.type === 'status_update') {
                                updateStatus(message.status);
                            } else if (message.type === 'debug') {
                                addLog(`[后端] ${message.message}`, 'debug');
                            } else {
                                addLog("收到文本消息: " + event.data, 'debug');
                            }
                        } catch (e) {
                            addLog("解析消息失败: " + e, 'error');
                        }
                    } else if (event.data instanceof ArrayBuffer) {
                        const audioData = event.data;
                        addLog(`[网络] 收到音频流: ${audioData.byteLength} 字节`, 'info');
                        if (player) {
                            player.playAudio(audioData);
                        } else {
                            addLog("播放器未初始化，丢弃音频数据", 'warning');
                        }
                    } else if (event.data instanceof Blob) {
                        // 某些浏览器可能将二进制包装成 Blob
                        addLog(`[网络] 收到 Blob 音频数据: ${event.data.size} 字节，正在转换...`, 'info');
                        const arrayBuffer = await event.data.arrayBuffer();
                        if (player) player.playAudio(arrayBuffer);
                    } else {
                        addLog(`收到未知格式消息: ${typeof event.data}`, 'warning');
                    }
                };

                websocket.onerror = (error) => {
                    if (websocket !== currentWebsocket) return;
                    addLog(`WebSocket错误: ${error}`);
                    updateStatus("disconnected", "连接错误");
                };

                websocket.onclose = (event) => {
                    if (websocket !== currentWebsocket) {
                        addLog("旧连接已关闭");
                        return;
                    }
                    
                    addLog(`连接已关闭 (代码: ${event.code})`);
                    if (recorder) recorder.stop();
                    if (player) player.stopCurrent(); // 确保停止时也停止当前播放
                    
                    if (!isManuallyStopped && reconnectAttempts < maxReconnectAttempts) {
                        reconnectAttempts++;
                        const delay = reconnectDelay * Math.pow(1.5, reconnectAttempts - 1);
                        updateStatus("disconnected", `连接断开，${(delay/1000).toFixed(1)}秒后重连...`);
                        setTimeout(connect, delay);
                    } else {
                        updateStatus("disconnected", "已断开连接");
                        startBtn.disabled = false;
                        stopBtn.disabled = true;
                        interruptBtn.disabled = true;
                    }
                };

            } catch (error) {
                addLog(`连接异常: ${error}`);
                updateStatus("disconnected", "连接异常");
                if (!isManuallyStopped && reconnectAttempts < maxReconnectAttempts) {
                    reconnectAttempts++;
                    setTimeout(connect, reconnectDelay);
                }
            }
        }

        // 管理员面板相关逻辑
        async function fetchActiveConnections() {
            if (!currentUser || currentUser.role !== 'admin') return;
            
            adminPanelContent.innerHTML = '<div style="text-align: center; padding: 50px;"><i class="fas fa-spinner fa-spin" style="font-size: 2rem; color: #a855f7;"></i><p>加载中...</p></div>';
            
            try {
                const response = await fetch('/admin/active_connections');
                if (response.ok) {
                    const connections = await response.json();
                    if (connections.length === 0) {
                        adminPanelContent.innerHTML = '<div style="text-align: center; padding: 50px; color: var(--text-muted);"><i class="fas fa-link-slash" style="font-size: 3rem; margin-bottom: 15px;"></i><p>当前没有活跃连接</p></div>';
                        return;
                    }
                    
                    let html = '<table style="width: 100%; border-collapse: collapse; margin-top: 10px;">';
                    html += '<tr style="text-align: left; border-bottom: 2px solid rgba(168, 85, 247, 0.3); color: var(--text-muted); font-size: 0.9rem;">';
                    html += '<th style="padding: 10px;">用户名</th><th style="padding: 10px;">连接ID</th><th style="padding: 10px;">空闲时长</th><th style="padding: 10px;">操作</th></tr>';
                    
                    connections.forEach(conn => {
                        const isCurrent = conn.connection_id === connId;
                        html += `<tr style="border-bottom: 1px solid rgba(255,255,255,0.05); ${isCurrent ? 'background: rgba(74, 108, 247, 0.1);' : ''}">`;
                        html += `<td style="padding: 15px;"><strong>${conn.user.username}</strong> ${conn.user.role === 'admin' ? '<span style="font-size: 0.7rem; background: #a855f7; padding: 2px 5px; border-radius: 4px; color: white; margin-left: 5px;">管理员</span>' : ''}</td>`;
                        html += `<td style="padding: 15px; font-family: monospace; font-size: 0.8rem; color: var(--text-muted);">${conn.connection_id}</td>`;
                        html += `<td style="padding: 15px;">${conn.idle_seconds}s</td>`;
                        html += `<td style="padding: 15px;">
                            ${isCurrent ? '<span style="color: var(--success); font-size: 0.8rem;">(当前设备)</span>' : 
                            `<button onclick="disconnectConn('${conn.connection_id}')" style="background: rgba(255, 107, 107, 0.2); border: 1px solid var(--accent); color: var(--accent); padding: 5px 10px; border-radius: 5px; cursor: pointer; font-size: 0.8rem;">
                                <i class="fas fa-unlink"></i> 断开
                            </button>`}
                        </td>`;
                        html += '</tr>';
                    });
                    html += '</table>';
                    adminPanelContent.innerHTML = html;
                } else {
                    adminPanelContent.innerHTML = `<div style="text-align: center; padding: 50px; color: var(--accent);"><p>获取连接列表失败: ${response.status}</p></div>`;
                }
            } catch (err) {
                adminPanelContent.innerHTML = `<div style="text-align: center; padding: 50px; color: var(--accent);"><p>网络错误: ${err.message}</p></div>`;
            }
        }

        window.disconnectConn = async (cid) => {
            if (!confirm(`确定要强制断开连接 ${cid} 吗？`)) return;
            try {
                const response = await fetch(`/admin/disconnect/${cid}`, { method: 'POST' });
                if (response.ok) {
                    addLog(`已成功断开连接: ${cid}`);
                    fetchActiveConnections();
                } else {
                    alert("断开连接失败");
                }
            } catch (err) {
                alert("网络错误: " + err.message);
            }
        };

        adminBtn.addEventListener('click', () => {
            adminPanelModal.style.display = 'block';
            fetchActiveConnections();
        });

        closeAdminPanelBtn.addEventListener('click', () => {
            adminPanelModal.style.display = 'none';
        });

        refreshAdminBtn.addEventListener('click', fetchActiveConnections);

        // 临时文件管理逻辑
        let cachedTempFilesData = null;

        async function fetchTempFiles() {
            const container = document.getElementById('tempFilesContent');
            if (container.innerHTML.trim() === '' || container.querySelector('.fa-spinner')) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 50px;">
                        <i class="fas fa-spinner fa-spin" style="font-size: 2rem; color: var(--primary);"></i>
                        <p>加载中...</p>
                    </div>
                `;
            }
            try {
                const response = await fetch('/temp_files');
                cachedTempFilesData = await response.json();
                renderTempFiles(cachedTempFilesData);
            } catch (error) {
                container.innerHTML = `<p style="color: var(--accent);">加载失败: ${error.message}</p>`;
            }
        }

        function renderTempFiles(data) {
            if (!data || Object.keys(data).length === 0) {
                tempFilesContent.innerHTML = '<p style="text-align: center; padding: 50px; color: var(--text-muted);">暂无临时文件</p>';
                return;
            }

            let html = '';
            for (const [date, files] of Object.entries(data)) {
                const dateId = `date-${date}`;
                
                // 检查该日期下是否所有文件都已选中
                const allSelected = files.length > 0 && files.every(f => selectedFiles.has(f.rel_path));

                html += `
                    <div style="margin-bottom: 20px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; background: rgba(74, 108, 247, 0.1); border-radius: 10px; margin-bottom: 10px;">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <input type="checkbox" id="check-${dateId}" onchange="toggleDateSelection('${date}', this.checked)" style="cursor: pointer;" ${allSelected ? 'checked' : ''}>
                                <h3 style="margin: 0; font-size: 1.1rem; color: var(--primary); cursor: pointer;" onclick="document.getElementById('check-${dateId}').click()">${date}</h3>
                            </div>
                            ${currentUser && currentUser.role === 'admin' ? `
                            <button onclick="deleteDateFiles('${date}')" style="background: none; border: none; color: var(--accent); cursor: pointer; font-size: 0.9rem;">
                                <i class="fas fa-trash"></i> 删除该日全部
                            </button>` : ''}
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px;">
                `;

                files.forEach(file => {
                    const relPath = file.rel_path;
                    const isSelected = selectedFiles.has(relPath);
                    const sizeMB = (file.size / (1024 * 1024)).toFixed(2);
                    const isUserFile = file.username && file.username !== 'default';
                    
                    html += `
                        <div onclick="toggleFileSelection('${relPath}')" style="padding: 10px; background: rgba(30, 41, 59, 0.5); border: 1px solid ${isSelected ? 'var(--primary)' : 'var(--glass-border)'}; border-radius: 8px; cursor: pointer; transition: var(--transition); position: relative;">
                            <div style="font-size: 0.85rem; word-break: break-all; margin-bottom: 5px;">${file.name}</div>
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div style="font-size: 0.75rem; color: var(--text-muted);">${sizeMB} MB</div>
                                ${currentUser && currentUser.role === 'admin' && isUserFile ? `<div style="font-size: 0.65rem; background: rgba(168, 85, 247, 0.2); color: #a855f7; padding: 1px 4px; border-radius: 3px;">${file.username}</div>` : ''}
                            </div>
                            ${isSelected ? '<div style="position: absolute; top: 5px; right: 5px; color: var(--primary);"><i class="fas fa-check-circle"></i></div>' : ''}
                        </div>
                    `;
                });

                html += `
                        </div>
                    </div>
                `;
            }
            tempFilesContent.innerHTML = html;
            updateBatchDeleteBtn();
        }

        function toggleDateSelection(date, isChecked) {
            if (!cachedTempFilesData || !cachedTempFilesData[date]) return;
            const files = cachedTempFilesData[date];
            files.forEach(file => {
                const relPath = file.rel_path;
                if (isChecked) {
                    selectedFiles.add(relPath);
                } else {
                    selectedFiles.delete(relPath);
                }
            });
            renderTempFiles(cachedTempFilesData);
        }

        function toggleFileSelection(relPath) {
            if (selectedFiles.has(relPath)) {
                selectedFiles.delete(relPath);
            } else {
                selectedFiles.add(relPath);
            }
            // 重新渲染当前数据
            renderTempFiles(cachedTempFilesData);
        }

        function updateBatchDeleteBtn() {
            const count = selectedFiles.size;
            selectedCountSpan.textContent = count;
            batchDeleteBtn.disabled = count === 0;
        }

        async function deleteDateFiles(date) {
            if (!confirm(`确定要删除 ${date} 的所有临时文件吗？`)) return;
            try {
                const response = await fetch(`/temp_files/date/${date}`, { method: 'DELETE' });
                const result = await response.json();
                if (result.status === 'ok') {
                    // 清除已选中的该日文件
                    for (const path of selectedFiles) {
                        if (path.startsWith(date + '/')) {
                            selectedFiles.delete(path);
                        }
                    }
                    // 重新获取数据
                    fetchTempFiles();
                } else {
                    alert('删除失败: ' + result.message);
                }
            } catch (error) {
                alert('删除失败: ' + error.message);
            }
        }

        async function batchDelete() {
            if (selectedFiles.size === 0) return;
            if (!confirm(`确定要删除选中的 ${selectedFiles.size} 个文件吗？`)) return;

            const filesArray = Array.from(selectedFiles);
            const query = filesArray.map(f => `files=${encodeURIComponent(f)}`).join('&');

            try {
                const response = await fetch(`/temp_files?${query}`, { method: 'DELETE' });
                const result = await response.json();
                if (result.status === 'ok') {
                    selectedFiles.clear();
                    fetchTempFiles();
                } else {
                    alert('删除失败');
                }
            } catch (error) {
                alert('删除失败: ' + error.message);
            }
        }

        // 事件监听
        tempFilesBtn.addEventListener('click', () => {
            tempFilesModal.style.display = 'block';
            fetchTempFiles();
        });

        closeTempFilesBtn.addEventListener('click', () => {
            tempFilesModal.style.display = 'none';
        });

        refreshTempFilesBtn.addEventListener('click', fetchTempFiles);
        batchDeleteBtn.addEventListener('click', batchDelete);

        window.onclick = (event) => {
            if (event.target === tempFilesModal) {
                tempFilesModal.style.display = 'none';
            }
            if (event.target === adminPanelModal) {
                adminPanelModal.style.display = 'none';
            }
        };

        // 配置 marked
        if (typeof marked !== 'undefined') {
            marked.setOptions({
                breaks: true, // 允许回车换行
                gfm: true,    // 使用 GitHub 风格的 Markdown
                headerIds: false
            });
        }

        // 更新对话
        function updateDialogue(newMessages) {
            const container = document.getElementById('messages-list');
            const maxHistory = 30; // 调高历史上限

            // 如果 newMessages 不是数组，包装成数组
            const messagesToAdd = Array.isArray(newMessages) ? newMessages : [newMessages];
            
            if (messagesToAdd.length > 0) {
                // 将新消息添加到历史记录并保存时间戳
                const now = new Date();
                const timestamp = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
                
                const messagesToAddWithTime = messagesToAdd.map(msg => ({
                    ...msg,
                    timestamp: msg.timestamp || timestamp
                }));
                
                dialogueHistory = [...dialogueHistory, ...messagesToAddWithTime];

                // 如果抽屉没打开，显示红点
                if (!dialogueContainer.classList.contains('active')) {
                    messageBadge.style.display = 'block';
                }
            }
            
            // 应用历史记录上限
            if (dialogueHistory.length > maxHistory) {
                dialogueHistory = dialogueHistory.slice(-maxHistory);
            }

            // 当有对话时，更新 body 类
            if (dialogueHistory.length > 0) {
                document.body.classList.add('has-dialogue');
            } else {
                document.body.classList.remove('has-dialogue');
            }

            // 清空容器重新渲染
            container.innerHTML = '';

            dialogueHistory.forEach(message => {
                const messageDiv = document.createElement('div');
                messageDiv.className = `message role-${message.role}`;

                // 使用 marked 解析 Markdown
                let renderedContent = message.content;
                if (typeof marked !== 'undefined') {
                    const contentStr = String(message.content || '');
                    renderedContent = marked.parse(contentStr);
                }

                messageDiv.innerHTML = `
                    <div class="message-content">
                        ${renderedContent}
                    </div>
                `;

                container.appendChild(messageDiv);
            });

            // 自动滚动到底部
            setTimeout(() => {
                dialogueContainer.scrollTo({
                    top: dialogueContainer.scrollHeight,
                    behavior: 'smooth'
                });
            }, 100);
        }

        function initAudioContext() {
            try {
                if (!globalAudioContext) {
                    const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                    if (!AudioContextClass) {
                        addLog("错误: 浏览器不支持 Web Audio API", "error");
                        return null;
                    }
                    globalAudioContext = new AudioContextClass();
                    
                    // 初始化分析器
                    globalAnalyser = globalAudioContext.createAnalyser();
                    globalAnalyser.fftSize = 256; // 较小的 FFT 尺寸以提高性能
                    const bufferLength = globalAnalyser.frequencyBinCount;
                    frequencyData = new Uint8Array(bufferLength);
                    
                    addLog("[系统] 音频上下文及分析器已初始化", "info");
                }
                if (globalAudioContext.state === 'suspended') {
                    globalAudioContext.resume().then(() => {
                        addLog("[系统] 音频上下文已恢复运行", "info");
                    });
                }
                return globalAudioContext;
            } catch (e) {
                addLog(`[系统] 初始化音频失败: ${e.message}`, "error");
                return null;
            }
        }

        class AudioPlayer {
            constructor(updateStatusFn, websocket) {
                this.audioContext = initAudioContext();
                this.audioQueue = [];
                this.rawQueue = [];
                this.isDecoding = false;
                this.isPlaying = false;
                this.shouldInterrupt = false;
                this.updateStatus = updateStatusFn;
                this.websocket = websocket;
                this.addLog("已就绪");
            }

            addLog(message) {
                addLog(`[播放器] ${message}`, 'info');
            }

            sendPlaybackStatus(status, queueSize) {
                if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                    const message = {
                        type: "playback_status",
                        status: status,
                        queue_size: queueSize,
                        timestamp: new Date().toISOString()
                    };
                    this.websocket.send(JSON.stringify(message));
                }
            }

            async playAudio(audioData) {
                if (!audioData || audioData.byteLength === 0) {
                    this.addLog("收到空音频数据，跳过");
                    return;
                }
                
                // 先入队，确保数据不丢失
                this.rawQueue.push(audioData);
                this.addLog(`音频数据已入队 (队列长度: ${this.rawQueue.length}, 大小: ${audioData.byteLength} 字节)`);

                // 异步处理，不阻塞主线程
                this.processRawQueue().catch(err => {
                    this.addLog(`处理音频队列异常: ${err.message}`, 'error');
                });
            }

            async processRawQueue() {
                if (this.isDecoding || this.rawQueue.length === 0) {
                    return;
                }
                
                this.isDecoding = true;
                
                while (this.rawQueue.length > 0) {
                    // 确保 AudioContext 在解码前是运行状态
                    if (this.audioContext.state === 'suspended') {
                        this.addLog("AudioContext 挂起中，尝试恢复...");
                        try {
                            await this.audioContext.resume();
                            this.addLog("AudioContext 已恢复");
                        } catch (e) {
                            this.addLog("无法恢复 AudioContext: " + e.message, 'warning');
                        }
                    }

                    const audioData = this.rawQueue.shift();
                    try {
                        const state = this.audioContext.state;
                        this.addLog(`开始解码音频块 (${audioData.byteLength} 字节), Context状态: ${state}`);
                        
                        // 检查是否是有效的 WAV/MP3 格式
                        const view = new Uint8Array(audioData);
                        const isWav = view[0] === 82 && view[1] === 73 && view[2] === 70 && view[3] === 70; // 'RIFF'
                        
                        // 如果后端发来的是原始 PCM 或者是损坏的文件，decodeAudioData 会失败
                        // 探测头部
                        const header = Array.from(view.slice(0, 4)).map(b => String.fromCharCode(b)).join('');
                        this.addLog(`音频探测: 格式=${isWav ? 'WAV' : '未知'}, 头=${header}`);

                        const bufferCopy = audioData.slice(0);
                        
                        let audioBuffer;
                        try {
                            // 优先使用现代 Promise 接口
                            audioBuffer = await this.audioContext.decodeAudioData(bufferCopy);
                        } catch (e) {
                            this.addLog(`解码失败 (${e.message})，尝试检查数据有效性...`, 'error');
                            // 失败时也给后端发个确认，避免后端超时等待
                            if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                                this.websocket.send(JSON.stringify({
                                    type: "playback_finished",
                                    error: "decode_failed"
                                }));
                            }
                            continue; // 跳过损坏的块
                        }
                        
                        this.audioQueue.push(audioBuffer);
                        this.addLog(`解码成功: 时长 ${audioBuffer.duration.toFixed(2)}s, 队列中待播放: ${this.audioQueue.length}`);
                        
                        if (!this.isPlaying) {
                            this.playNext();
                        }
                    } catch (error) {
                        this.addLog(`解码循环异常: ${error.message || error}`, 'error');
                    }
                }
                this.isDecoding = false;
            }

            playNext() {
                if (this.audioQueue.length === 0) {
                    this.isPlaying = false;
                    this.updateStatus('idle');
                    this.sendPlaybackStatus('stopped', 0);
                    return;
                }

                try {
                    this.isPlaying = true;
                    this.updateStatus('speaking');
                    const audioBuffer = this.audioQueue.shift();
                    
                    // 检查音频内容是否全为0 (静音检测)
                    const data = audioBuffer.getChannelData(0);
                    let maxAmp = 0;
                    for (let i = 0; i < Math.min(data.length, 1000); i++) {
                        if (Math.abs(data[i]) > maxAmp) maxAmp = Math.abs(data[i]);
                    }
                    this.addLog(`准备播放: 时长=${audioBuffer.duration.toFixed(2)}s, 最大振幅(前1000采样)=${maxAmp.toFixed(4)}`);

                    const source = this.audioContext.createBufferSource();
                    source.buffer = audioBuffer;
                    
                    // 连接到分析器，再连接到输出
                    source.connect(globalAnalyser);
                    source.connect(this.audioContext.destination);
                    
                    this.source = source;

                    this.addLog(`正在启动播放器... Context状态: ${this.audioContext.state}`);
                    this.sendPlaybackStatus('playing', this.audioQueue.length);
                    
                    source.onended = () => {
                        this.addLog("播放结束");
                        
                        // 发送确认给后端，解决 WebSocketPlayer 的 wait 阻塞
                        if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                            this.websocket.send(JSON.stringify({
                                type: "playback_finished",
                                timestamp: new Date().toISOString()
                            }));
                        }

                        if (this.shouldInterrupt) {
                            this.sendPlaybackStatus('interrupted', this.audioQueue.length);
                            this.shouldInterrupt = false;
                        } else {
                            this.sendPlaybackStatus('completed', this.audioQueue.length);
                        }
                        
                        if (this.audioQueue.length > 0) {
                    this.playNext();
                } else {
                    // 确保最后一段播放完也发送状态
                    this.isPlaying = false;
                    this.updateStatus("idle");
                }
            };

            source.start(0);
        } catch (e) {
            this.addLog("启动播放失败: " + e);
            // 失败时也要尝试通知后端，否则后端会一直阻塞
            if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                this.websocket.send(JSON.stringify({
                    type: "playback_finished",
                    error: e.message
                }));
            }
            this.isPlaying = false;
            this.sendPlaybackStatus('error', this.audioQueue.length);
            this.playNext(); // 尝试播放下一个
        }
    }

            stopCurrent() {
                if (this.source) {
                    try {
                        this.source.stop();
                    } catch (e) {}
                    this.source = null;
                }
                this.isPlaying = false;
            }

            interrupt() {
                this.shouldInterrupt = true;
                this.audioQueue = [];
                this.rawQueue = [];
                this.stopCurrent();
                this.addLog("已中断播放");
                this.updateStatus("idle");
                this.sendPlaybackStatus('interrupted', 0);
            }
        }

        // 改写的 WebRecorder，发送原始 PCM
        class WebRecorder {
            constructor(websocket) {
                this.websocket = websocket;
                this.audioContext = null;
                this.processor = null;
                this.source = null;
                this.stream = null;
                this.isRecording = false;

                // 配置参数
                this.inputSampleRate = 48000;  // 大多数浏览器默认采样率
                this.outputSampleRate = 16000; // 你需要的采样率
            }

            addLog(message) {
                addLog(`[录音器] ${message}`, 'info');
            }

            // 采样率转换（降采样）
            downsampleBuffer(buffer, inputSampleRate, outputSampleRate) {
                if (outputSampleRate === inputSampleRate) {
                    return buffer;
                }
                const sampleRateRatio = inputSampleRate / outputSampleRate;
                const newLength = Math.round(buffer.length / sampleRateRatio);
                const result = new Float32Array(newLength);
                let offsetResult = 0;
                let offsetBuffer = 0;
                while (offsetResult < result.length) {
                    const nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);
                    // 对应多个输入样本的平均值
                    let accum = 0, count = 0;
                    for (let i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {
                        accum += buffer[i];
                        count++;
                    }
                    result[offsetResult] = accum / count;
                    offsetResult++;
                    offsetBuffer = nextOffsetBuffer;
                }
                return result;
            }

            // float32 转 int16
            floatTo16BitPCM(input) {
                const output = new Int16Array(input.length);
                for (let i = 0; i < input.length; i++) {
                    let s = Math.max(-1, Math.min(1, input[i]));
                    output[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                }
                return output;
            }

            async start() {
                try {
                    if (!window.isSecureContext && window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') {
                        this.addLog("警告: 正在非安全环境(非HTTPS/非localhost)下运行，浏览器可能拦截麦克风访问", 'error');
                        alert("浏览器安全策略限制：在局域网访问时，必须使用 HTTPS 协议或在浏览器设置中开启授权，否则无法使用麦克风。\n\n建议：\n1. 使用 https:// 访问\n2. 或者在 Chrome/Edge 浏览器地址栏输入 chrome://flags/#unsafely-treat-insecure-origin-as-secure，并将当前地址设为允许。");
                    }

                    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                        this.addLog("错误: 浏览器不支持 getUserMedia 或权限被禁用", 'error');
                        throw new Error("浏览器不支持麦克风访问或由于非安全上下文被禁用");
                    }

                    this.stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        } 
                    });
                    // 使用全局 AudioContext 以确保状态一致且绕过自动播放限制
                    this.audioContext = initAudioContext();

                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                        this.addLog("音频上下文已从暂停中恢复");
                    }

                    this.addLog(`采样率: ${this.audioContext.sampleRate}Hz`);

                    // 连接麦克风流
                    this.source = this.audioContext.createMediaStreamSource(this.stream);
                    
                    // 连接到全局分析器
                    this.source.connect(globalAnalyser);

                    // 处理节点
                    const bufferSize = 4096;
                    this.processor = this.audioContext.createScriptProcessor(bufferSize, 1, 1);

                    let frameCount = 0;
                    let hasReceivedFirstFrame = false;
                    this.processor.onaudioprocess = (e) => {
                        if (!this.isRecording) return;
                        
                        if (!hasReceivedFirstFrame) {
                            this.addLog("收到首帧音频输入，正在处理...");
                            hasReceivedFirstFrame = true;
                        }

                        let inputData = e.inputBuffer.getChannelData(0); 

                        // 先降采样到16kHz
                        let downsampledBuffer = this.downsampleBuffer(inputData, this.audioContext.sampleRate, this.outputSampleRate);

                        // 转16bit PCM
                        let int16Buffer = this.floatTo16BitPCM(downsampledBuffer);

                        // 发送二进制数据
                        if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                            this.websocket.send(int16Buffer.buffer);
                            
                            // 每发送 100 帧记录一次日志，避免刷屏但能确认在运行
                            frameCount++;
                            if (frameCount % 100 === 0) {
                                this.addLog(`正在传输语音数据... (已发送 ${frameCount} 帧)`, 'debug');
                            }
                        }
                    };

                    // 连接处理节点
                    // 使用 GainNode 并设为 0 以防止在某些浏览器中 onaudioprocess 不触发，同时避免回音
                    this.source.connect(this.processor);
                    const silentGain = this.audioContext.createGain();
                    silentGain.gain.value = 0;
                    this.processor.connect(silentGain);
                    silentGain.connect(this.audioContext.destination);

                    this.isRecording = true;
                    this.addLog("录音已启动（PCM采样）");
                    return true;
                } catch (error) {
                    this.addLog(`录音启动失败: ${error}`);
                    return false;
                }
            }

            stop() {
                if (!this.isRecording) return;

                this.isRecording = false;
                this.addLog("录音已停止");

                if (this.processor) {
                    this.processor.disconnect();
                    this.processor = null;
                }
                if (this.source) {
                    this.source.disconnect();
                    this.source = null;
                }
                // 不要关闭共享的 audioContext，只需断开连接即可
                if (this.audioContext) {
                    this.audioContext = null;
                }
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                    this.stream = null;
                }
            }
        }


        startBtn.addEventListener('click', async () => {
            // 在用户交互时初始化音频上下文，解决自动播放限制
            initAudioContext();
            
            isManuallyStopped = false;
            reconnectAttempts = 0;
            if (websocket) {
                websocket.close();
            }
            if (recorder) {
                recorder.stop();
            }
            connect();
        });

        stopBtn.addEventListener('click', () => {
            isManuallyStopped = true;
            if (websocket) websocket.close();
            if (recorder) recorder.stop();
            updateStatus("disconnected", "已手动停止");
            startBtn.disabled = false;
            stopBtn.disabled = true;
            interruptBtn.disabled = true;
            addLog("对话已手动停止");
        });

        interruptBtn.addEventListener('click', () => {
            if (player) {
                player.interrupt();
                addLog("手动触发打断");
            }
        });

        // 初始化日志
        addLog("系统初始化完成");
        addLog("欢迎使用百聆 (BaiLing)", 'system');

        // 模拟初始对话数据
        setTimeout(() => {
            const initialDialogue = [
                { role: 'system', content: '欢迎使用百聆实时对话系统，请点击开始对话按钮进行对话' },
                { role: 'bot', content: '您好！我是百聆智能语音助手，有什么可以帮您的吗？' }
            ];
            updateDialogue(initialDialogue);
        }, 1500);

    </script>
</body>
</html>
